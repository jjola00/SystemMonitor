main.py:
<code>
# backend/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from api import system_router, weather_router, crypto_router

app = FastAPI(title="System Monitor API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:8080"], 
    allow_credentials=True,
    allow_methods=["*"], 
    allow_headers=["*"], 
)

app.include_router(system_router.router, prefix="/api")
app.include_router(weather_router.router, prefix="/api")
app.include_router(crypto_router.router, prefix="/api")
</code>

test.py:
<code>
from config.config import Config
print(Config.WEATHER_API_KEY)  

</code>

api\crypto_router.py:
<code>
# backend/api/crypto_router.py
from fastapi import APIRouter
from services.crypto_service import store_crypto_metrics, fetch_crypto_metrics
from utils.logger import log_info

router = APIRouter()

@router.post("/metrics/crypto/upload")
def upload_crypto_metrics():
    """Fetches and stores crypto metrics."""
    log_info("Uploading crypto metrics.")
    return store_crypto_metrics()

@router.get("/metrics/crypto")
def get_crypto_metrics(limit: int = 10):
    """Fetch latest crypto metrics."""
    log_info(f"Fetching latest {limit} crypto metrics.")
    return fetch_crypto_metrics(limit)
</code>

api\system_router.py:
<code>
# backend/api/system_router.py
from fastapi import APIRouter
from services.system_service import store_local_metrics, fetch_local_metrics
from utils.logger import log_info

router = APIRouter()

@router.post("/metrics/system/upload")
def upload_system_metrics():
    """Fetches and stores system metrics."""
    log_info("Uploading system metrics.")
    return store_local_metrics()

@router.get("/metrics/system")
def get_system_metrics(limit: int = 10):
    """Fetch latest system metrics."""
    log_info(f"Fetching latest {limit} system metrics.")
    return fetch_local_metrics(limit)
</code>

api\weather_router.py:
<code>
# backend/api/routers/weather_router.py
from fastapi import APIRouter
from services.weather_service import store_weather_metrics, fetch_weather_metrics
from utils.logger import log_info

router = APIRouter()

@router.post("/metrics/weather/upload")
def upload_weather_metrics():
    """Fetches and stores weather metrics."""
    log_info("Uploading weather metrics.")
    return store_weather_metrics()

@router.get("/metrics/weather")
def get_weather_metrics(limit: int = 10):
    """Fetch latest weather metrics."""
    log_info(f"Fetching latest {limit} weather metrics.")
    return fetch_weather_metrics(limit)
</code>

collectors\system_collector.py:
<code>
# backend/collectors/system_collector.py
import psutil
from datetime import datetime, timezone
from utils.logger import log_info, log_error  

def collect_system_metrics():
    """Collects CPU and RAM usage metrics from the system."""
    log_info("Collecting system metrics...") 
    try:
        metrics = {
            "device_name": "test",
            "cpu_usage": psutil.cpu_percent(interval=1),
            "ram_usage": psutil.virtual_memory().percent,
            "timestamp": datetime.now(timezone.utc).isoformat()
        }
        log_info("System metrics collected successfully.") 
        return metrics
    except Exception as e:
        log_error(f"Error collecting system metrics: {e}") 
        return None

</code>

collectors\third_party_collector.py:
<code>
import requests
from config.config import Config
from utils.logger import log_info, log_error

def fetch_weather_metric():
    """Fetches temperature from the weather API."""
    if not Config.WEATHER_API_URL or not Config.WEATHER_API_KEY:
        log_error("Missing weather API credentials.")
        return None

    # Define the parameters for the API request
    params = {
        "location": "Dublin",  # Specify the location
        "apikey": Config.WEATHER_API_KEY,  # Your API key
        "fields": ["temperature"],  # Specify the fields you want to retrieve
        "units": "metric"  # Specify the unit (metric for Celsius, imperial for Fahrenheit)
    }

    url = Config.WEATHER_API_URL
    log_info(f"Fetching weather metric from {url}")

    try:
        response = requests.get(url, params=params)
        response.raise_for_status()

        data = response.json()
        if "data" in data and "timelines" in data["data"]:
            timelines = data["data"]["timelines"]
            if timelines and "intervals" in timelines[0]:
                intervals = timelines[0]["intervals"]
                if intervals and "values" in intervals[0]:
                    temperature = intervals[0]["values"].get("temperature")
                    return temperature

        log_error("Temperature data not found in the response.")
        return None
    except requests.RequestException as e:
        log_error(f"Weather API error: {e}")
        return None

def fetch_crypto_metric():
    """Fetches Bitcoin price from CoinGecko and includes the unit."""
    if not Config.CRYPTO_API_URL:
        log_error("Missing CoinGecko API credentials.")
        return None

    url = f"{Config.CRYPTO_API_URL}/simple/price?ids=bitcoin&vs_currencies=usd"
    log_info(f"Fetching crypto metric from {url}")

    try:
        response = requests.get(url)
        response.raise_for_status()
        data = response.json().get("bitcoin", {})

        if "usd" in data:
            return {"value": data["usd"], "unit": "USD"}
        
        log_error("Crypto API returned empty data.")
        return None
    except requests.RequestException as e:
        log_error(f"Crypto API error: {e}")
        return None
</code>

config\config.py:
<code>
import os
from dotenv import load_dotenv

env_path = os.path.join(os.path.dirname(__file__), "secrets.env")
load_dotenv(env_path)

class Config:
    SUPABASE_URL = os.getenv("SUPABASE_URL")
    SUPABASE_KEY = os.getenv("SUPABASE_KEY")
    AGGREGATOR_API = os.getenv("AGGREGATOR_API")
    DEVICE_NAME = os.getenv("DEVICE_NAME", "Unnamed Device") 

    WEATHER_API_URL = os.getenv("WEATHER_API_URL")
    WEATHER_API_KEY = os.getenv("WEATHER_API_KEY")

    CRYPTO_API_URL = os.getenv("CRYPTO_API_URL")

    @staticmethod
    def validate():
        """Ensure critical configs are set."""
        missing = [key for key in ["SUPABASE_URL", "SUPABASE_KEY", "AGGREGATOR_API", "WEATHER_API_URL", "WEATHER_API_KEY", "CRYPTO_API_URL"] if not getattr(Config, key)]
        if missing:
            raise ValueError(f"Missing required environment variables: {', '.join(missing)}")

Config.validate()

</code>

database\db_connection.py:
<code>
from supabase import create_client, Client
from config.config import Config

try:
    db_client: Client = create_client(Config.SUPABASE_URL, Config.SUPABASE_KEY)
except Exception as e:
    raise RuntimeError(f"Database connection failed: {e}")

</code>

database\repositories\device_repository.py:
<code>
# backend/database/repositories/device_repository.py
from database.db_connection import db_client
from datetime import datetime, timezone

class DeviceRepository:
    def get_or_create_device_id(self, device_name, ip_address=None):
        """Fetch device ID by name, or insert it if not found."""
        response = db_client.table("devices").select("id, ip_address").eq("name", device_name).execute()
        
        if response.data:
            device_id = response.data[0]["id"]
            if ip_address and response.data[0].get("ip_address") != ip_address:
                db_client.table("devices").update({"ip_address": ip_address}).eq("id", device_id).execute()
            return device_id
        
        new_device = {"name": device_name, "ip_address": ip_address, "created_at": datetime.now(timezone.utc).isoformat()}
        insert_response = db_client.table("devices").insert(new_device).execute()
        
        return insert_response.data[0]["id"] if insert_response.data else None
</code>

database\repositories\metric_repository.py:
<code>
# backend/database/repositories/metric_repository.py
from database.db_connection import db_client
from datetime import datetime, timezone
from .device_repository import DeviceRepository
from utils.cache import cache
from utils.logger import log_info

class MetricRepository:
    def get_or_create_metric_id(self, metric_name, unit=None):
        """
        Fetch metric ID by name with caching, or create it if it doesn't exist.
        """
        # Try to get from cache first
        cache_key = f"metric_id_{metric_name}"
        cached_id = cache.get(cache_key)
        
        if cached_id:
            return cached_id
            
        # Not in cache, fetch from database
        response = db_client.table("metrics").select("id").eq("name", metric_name).execute()
        
        if response.data:
            # Metric exists, cache and return its ID
            metric_id = response.data[0]["id"]
            cache.set(cache_key, metric_id, ttl_seconds=3600)  # Cache for 1 hour
            return metric_id
        
        # Metric doesn't exist, create it
        new_metric = {"name": metric_name, "unit": unit}
        insert_response = db_client.table("metrics").insert(new_metric).execute()
        
        if insert_response.data:
            metric_id = insert_response.data[0]["id"]
            cache.set(cache_key, metric_id, ttl_seconds=3600)  # Cache for 1 hour
            return metric_id
        else:
            raise ValueError(f"Failed to create metric: {metric_name}")

    def insert_device_metrics(self, device_id, metrics):
        """
        Insert device metrics into the database.
        metrics: A dictionary where keys are metric names and values are metric values.
        """
        records = []
        for metric_name, value in metrics.items():
            if metric_name == "timestamp" or metric_name == "device_name":
                continue
                
            metric_id = self.get_or_create_metric_id(metric_name)
            records.append({
                "device_id": device_id,
                "metric_id": metric_id,
                "value": value,
                "timestamp": datetime.now(timezone.utc).isoformat()
            })

        if records:
            db_client.table("device_metrics").insert(records).execute()

    def insert_weather_metric(self, weather_temp):
        """
        Insert weather metrics into the database.
        """
        device_repo = DeviceRepository()
        metric_id = self.get_or_create_metric_id("weather_temp", unit="°C")
        device_id = device_repo.get_or_create_device_id("WeatherMonitor")

        db_client.table("device_metrics").insert([
            {
                "device_id": device_id,
                "metric_id": metric_id,
                "value": weather_temp,
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
        ]).execute()
        
        # Clear any cached weather metrics
        cache.delete("weather_metrics")

    def insert_crypto_metric(self, crypto_price):
        """
        Insert crypto metrics into the database.
        """
        device_repo = DeviceRepository()
        metric_id = self.get_or_create_metric_id("crypto_price", unit="USD")
        device_id = device_repo.get_or_create_device_id("CryptoMonitor")

        db_client.table("device_metrics").insert([
            {
                "device_id": device_id,
                "metric_id": metric_id,
                "value": crypto_price["value"],
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
        ]).execute()
        
        # Clear any cached crypto metrics
        cache.delete("crypto_metrics")

    def fetch_metrics(self, metric_names, limit=10):
        """
        Fetch latest metrics by names.
        """
        log_info(f"Executing database query for metrics: {metric_names}")
        
        # First, get the metric IDs for the requested names
        metric_ids_response = db_client.table("metrics") \
            .select("id") \
            .in_("name", metric_names) \
            .execute()
        
        if not metric_ids_response.data:
            return {"message": f"No metrics found for {metric_names}"}
        
        metric_ids = [item["id"] for item in metric_ids_response.data]
        
        # Then fetch the actual metrics using these IDs
        response = db_client.table("device_metrics") \
            .select("value, timestamp, metrics(name)") \
            .in_("metric_id", metric_ids) \
            .order("timestamp", desc=True) \
            .limit(limit) \
            .execute()
        
        return response.data or {"message": f"No metrics found for {metric_names}"}
</code>

services\crypto_service.py:
<code>
# backend/services/crypto_service.py
from database.repositories.metric_repository import MetricRepository
from collectors.third_party_collector import fetch_crypto_metric
from utils.logger import log_info
from utils.cache import cache
from utils.cache_decorators import cached

def store_crypto_metrics():
    """Fetches and stores crypto metrics."""
    metric_repo = MetricRepository()
    crypto_price = fetch_crypto_metric()

    if crypto_price is not None:
        metric_repo.insert_crypto_metric(crypto_price)
        
        # Invalidate the cache after new data is stored
        cache.delete("crypto_metrics")
        
        log_info("Crypto metrics stored successfully.")
        return {"status": "success"}
    return {"status": "error", "message": "Failed to fetch crypto data"}

@cached(ttl_seconds=120, key_prefix="crypto_metrics")  # 2 minute cache for crypto
def fetch_crypto_metrics(limit=10):
    """Fetches latest crypto metrics with caching."""
    log_info(f"Cache miss - fetching latest {limit} crypto metrics from database.")
    metric_repo = MetricRepository()
    return metric_repo.fetch_metrics(["crypto_price"], limit)
</code>

services\system_service.py:
<code>
# backend/services/system_service.py
from database.repositories.device_repository import DeviceRepository
from database.repositories.metric_repository import MetricRepository
from collectors.system_collector import collect_system_metrics
from utils.logger import log_info
from fastapi import HTTPException
from utils.cache import cache
from utils.cache_decorators import cached

def store_local_metrics():
    """Fetches and stores CPU and RAM usage."""
    metrics = collect_system_metrics()
    
    if metrics is not None:
        device_repo = DeviceRepository()
        metric_repo = MetricRepository()
        
        device_id = device_repo.get_or_create_device_id(metrics["device_name"])
        
        metric_repo.insert_device_metrics(device_id, metrics)
        
        # Invalidate the cache after new data is stored
        cache.delete("local_metrics")
        
        log_info("Local metrics stored successfully.")
        return {"status": "success"}
    else:
        raise HTTPException(status_code=500, detail="Failed to collect system metrics")    

@cached(ttl_seconds=60, key_prefix="local_metrics")
def fetch_local_metrics(limit=10):
    """Fetches latest local device metrics with caching."""
    log_info(f"Cache miss - fetching latest {limit} local metrics from database.")
    metric_repo = MetricRepository()
    return metric_repo.fetch_metrics(["cpu_usage", "ram_usage"], limit)
</code>

services\weather_service.py:
<code>
# backend/services/weather_service.py
from database.repositories.metric_repository import MetricRepository
from collectors.third_party_collector import fetch_weather_metric
from utils.logger import log_info
from utils.cache import cache
from utils.cache_decorators import cached

def store_weather_metrics():
    """Fetches and stores weather metrics."""
    metric_repo = MetricRepository()
    weather_temp = fetch_weather_metric()

    if weather_temp is not None:
        metric_repo.insert_weather_metric(weather_temp)
        
        # Invalidate the cache after new data is stored
        cache.delete("weather_metrics")
        
        log_info("Weather metrics stored successfully.")
        return {"status": "success"}
    return {"status": "error", "message": "Failed to fetch weather data"}

@cached(ttl_seconds=300, key_prefix="weather_metrics")  # 5 minute cache for weather
def fetch_weather_metrics(limit=10):
    """Fetches latest weather metrics with caching."""
    log_info(f"Cache miss - fetching latest {limit} weather metrics from database.")
    metric_repo = MetricRepository()
    return metric_repo.fetch_metrics(["weather_temp"], limit)
</code>

utils\cache.py:
<code>
# backend/utils/cache.py
from datetime import datetime, timedelta
import threading

class Cache:
    """Simple in-memory cache with expiration"""
    
    def __init__(self):
        self._cache = {}
        self._lock = threading.Lock()
    
    def get(self, key):
        """Get a value from cache if it exists and hasn't expired"""
        with self._lock:
            if key in self._cache:
                item = self._cache[key]
                if item['expiry'] > datetime.now():
                    return item['value']
                del self._cache[key]
        return None
    
    def set(self, key, value, ttl_seconds=300):
        """Set a value in cache with expiration time"""
        with self._lock:
            self._cache[key] = {
                'value': value,
                'expiry': datetime.now() + timedelta(seconds=ttl_seconds)
            }
    
    def delete(self, key):
        """Remove a specific key from cache"""
        with self._lock:
            if key in self._cache:
                del self._cache[key]
    
    def clear(self):
        """Clear all cached items"""
        with self._lock:
            self._cache.clear()

cache = Cache()
</code>

utils\cache_decorators.py:
<code>
# backend/utils/cache_decorators.py
from functools import wraps
from utils.cache import cache

def cached(ttl_seconds=300, key_prefix=""):
    """
    Decorator to cache function results.
    
    Args:
        ttl_seconds: Time to live in seconds
        key_prefix: Prefix for cache keys
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Create a cache key based on function name, args, and kwargs
            key_parts = [key_prefix, func.__name__]
            for arg in args:
                key_parts.append(str(arg))
            for k, v in sorted(kwargs.items()):
                key_parts.append(f"{k}={v}")
            
            cache_key = "_".join(key_parts)
            
            # Try to get from cache
            cached_result = cache.get(cache_key)
            if cached_result is not None:
                return cached_result
            
            # Execute the function and cache the result
            result = func(*args, **kwargs)
            cache.set(cache_key, result, ttl_seconds)
            return result
        
        return wrapper
    
    return decorator
</code>

utils\helpers.py:
<code>
import socket

def get_local_ip():
    """Get the local IP address of the current machine"""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))  
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception:
        # Fallback method
        return socket.gethostbyname(socket.gethostname())
</code>

utils\logger.py:
<code>
import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("system_monitor.log"),  
        logging.StreamHandler()  
    ]
)

logger = logging.getLogger(__name__)

def log_info(message: str):
    """Log an info message."""
    logger.info(message)

def log_warning(message: str):
    """Log a warning message."""
    logger.warning(message)

def log_error(message: str):
    """Log an error message."""
    logger.error(message)

def log_debug(message: str):
    """Log a debug message (useful for development)."""
    logger.debug(message)

</code>

