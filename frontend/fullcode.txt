package.json:
<code>
{
  "name": "system-monitoring-dashboard",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "chart.js": "^4.2.1",
    "chartjs-adapter-date-fns": "^3.0.0",
    "date-fns": "^2.29.3",
    "react": "^18.2.0",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^18.2.0",
    "react-gauge-component": "^1.2.64",
    "react-router-dom": "^6.30.0",
    "react-scripts": "5.0.1",
    "styled-components": "^5.3.11",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "proxy": "http://localhost:8000"
}

</code>

README.md:
<code>
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)

</code>

src\App.jsx:
<code>
import React, { useState, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { 
  Container, 
  HeaderBanner, 
  Navigation, 
  NavList, 
  Link, 
  ErrorContainer,
  RetryButton,
  Button
} from './styles/StyledComponents';
import Chart from './components/Chart';
import Gauge from './components/Gauge';
import Table from './components/Table';
import Loading from './components/Loading';

function App() {
  const [systemMetrics, setSystemMetrics] = useState([]);
  const [weatherMetrics, setWeatherMetrics] = useState([]);
  const [cryptoMetrics, setCryptoMetrics] = useState([]);
  const [loading, setLoading] = useState(false); // For upload process
  const [error, setError] = useState(null);
  const [isUploading, setIsUploading] = useState(false); // State to track if uploading is active

  // Fetch metrics history on initial load
  useEffect(() => {
    fetchAllMetrics();
  }, []);

  // Fetch all metrics (history)
  const fetchAllMetrics = async () => {
    try {
      const [systemResponse, weatherResponse, cryptoResponse] = await Promise.all([
        fetch('/api/metrics/system'),
        fetch('/api/metrics/weather'),
        fetch('/api/metrics/crypto')
      ]);

      if (!systemResponse.ok || !weatherResponse.ok || !cryptoResponse.ok) {
        throw new Error('Failed to fetch metrics');
      }

      const [systemData, weatherData, cryptoData] = await Promise.all([
        systemResponse.json(),
        weatherResponse.json(),
        cryptoResponse.json()
      ]);

      setSystemMetrics(systemData);
      setWeatherMetrics(weatherData);
      setCryptoMetrics(cryptoData);
    } catch (err) {
      console.error('Error fetching metrics:', err);
      setError(err.message);
    }
  };

  // Upload metrics
  const uploadMetrics = async () => {
    setLoading(true);
    setError(null);

    try {
      const [systemUpload, weatherUpload, cryptoUpload] = await Promise.all([
        fetch('/api/metrics/system/upload', { method: 'POST' }),
        fetch('/api/metrics/weather/upload', { method: 'POST' }),
        fetch('/api/metrics/crypto/upload', { method: 'POST' })
      ]);

      if (!systemUpload.ok || !weatherUpload.ok || !cryptoUpload.ok) {
        throw new Error('Failed to upload metrics');
      }

      // After uploading, fetch the updated metrics
      await fetchAllMetrics();
    } catch (err) {
      console.error('Error uploading metrics:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  // Start uploading metrics when isUploading is true
  useEffect(() => {
    if (isUploading) {
      const intervalId = setInterval(uploadMetrics, 30000); // Upload every 30 seconds
      return () => clearInterval(intervalId); // Cleanup interval on component unmount
    }
  }, [isUploading]);

  // Get the latest CPU and RAM usage values
  const latestCpuUsage = systemMetrics.find(metric => metric.metrics?.name === 'cpu_usage')?.value || 0;
  const latestRamUsage = systemMetrics.find(metric => metric.metrics?.name === 'ram_usage')?.value || 0;

  return (
    <Router future={{ v7_startTransition: true, v7_relativeSplatPath: true }}>
      <Container>
        <HeaderBanner>System Monitoring Dashboard</HeaderBanner>
        <Navigation>
          <NavList>
            <li><Link to="/">Dashboard</Link></li>
            <li><Link to="/system">System Metrics</Link></li>
            <li><Link to="/weather">Weather Metrics</Link></li>
            <li><Link to="/crypto">Crypto Metrics</Link></li>
          </NavList>
        </Navigation>

        {/* Button to start/stop uploading metrics */}
        <Button 
          onClick={() => setIsUploading(!isUploading)} 
          style={{ marginBottom: '20px' }}
        >
          {isUploading ? 'Stop Uploading Metrics' : 'Start Uploading Metrics'}
        </Button>

        {error && (
          <ErrorContainer>
            <p>Error: {error}</p>
            <RetryButton onClick={uploadMetrics}>Retry</RetryButton>
          </ErrorContainer>
        )}

        {/* Gauges for CPU and RAM Usage */}
        <div style={{ display: 'flex', gap: '20px', marginBottom: '20px' }}>
          <Gauge 
            title="CPU Usage" 
            value={latestCpuUsage} 
            minValue={0} 
            maxValue={100} 
            unit="%"
          />
          <Gauge 
            title="RAM Usage" 
            value={latestRamUsage} 
            minValue={0} 
            maxValue={100} 
            unit="%"
          />
        </div>
        
        <Routes>
          <Route path="/" element={
            <>
              <Table 
                systemMetrics={systemMetrics}
                weatherMetrics={weatherMetrics}
                cryptoMetrics={cryptoMetrics}
                loading={loading}
              />
            </>
          } />
          <Route path="/system" element={
            <Chart 
              metricData={systemMetrics} 
              title="System Metrics" 
              loading={loading}
              metricType="system"
            />
          } />
          <Route path="/weather" element={
            <Chart 
              metricData={weatherMetrics} 
              title="Weather Metrics" 
              loading={loading}
              metricType="weather"
            />
          } />
          <Route path="/crypto" element={
            <Chart 
              metricData={cryptoMetrics} 
              title="Crypto Metrics" 
              loading={loading}
              metricType="crypto"
            />
          } />
        </Routes>
      </Container>
    </Router>
  );
}

export default App;
</code>

src\config.js:
<code>
// Base URL for API calls
export const apiUrl = 'http://localhost:8000'; // Change this if your FastAPI backend runs on a different port

// Chart color schemes
export const chartColors = {
  system: {
    cpu: {
      borderColor: 'rgb(255, 99, 132)',
      backgroundColor: 'rgba(255, 99, 132, 0.5)',
    },
    ram: {
      borderColor: 'rgb(53, 162, 235)',
      backgroundColor: 'rgba(53, 162, 235, 0.5)',
    }
  },
  weather: {
    temp: {
      borderColor: 'rgb(255, 159, 64)',
      backgroundColor: 'rgba(255, 159, 64, 0.5)',
    }
  },
  crypto: {
    price: {
      borderColor: 'rgb(75, 192, 192)',
      backgroundColor: 'rgba(75, 192, 192, 0.5)',
    }
  }
};

// External trading sites for crypto
export const tradingSites = {
  BTC: 'https://www.binance.com/en/trade/BTC_USDT',
};

// Gauge configurations
export const gaugeConfigs = {
  cpu: {
    min: 0,
    max: 100,
    arc: {
      width: 0.2,
      padding: 0.05,
      cornerRadius: 1
    },
    pointer: {
      elastic: true
    },
    colors: {
      low: '#4CAF50',  // Green
      medium: '#FFC107', // Yellow
      high: '#F44336'   // Red
    }
  },
  ram: {
    min: 0,
    max: 100,
    arc: {
      width: 0.2,
      padding: 0.05,
      cornerRadius: 1
    },
    pointer: {
      elastic: true
    },
    colors: {
      low: '#4CAF50',  // Green
      medium: '#FFC107', // Yellow
      high: '#F44336'   // Red
    }
  },
  weather: {
    min: -20,
    max: 50,
    arc: {
      width: 0.2,
      padding: 0.05,
      cornerRadius: 1
    },
    pointer: {
      elastic: true
    },
    colors: {
      arcColors: ['#2196F3', '#4CAF50', '#F44336']  // Gradient from blue to green to red
    }
  }
};
</code>

src\index.css:
<code>
/*frontend/src/index.css*/
body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
      'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
      sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    background-color: #f0f2f5;
  }
  
  code {
    font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
      monospace;
  }
  
  * {
    box-sizing: border-box;
  }
</code>

src\index.js:
<code>
//frontend/src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</code>

src\components\Chart.jsx:
<code>
import React from 'react';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
  TimeScale
} from 'chart.js';
import { Line } from 'react-chartjs-2';
import 'chartjs-adapter-date-fns';
import { Button, MetricHeading } from '../styles/StyledComponents';
import { chartColors } from '../config';
import Loading from './Loading';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
  TimeScale
);

const Chart = ({ metricData, title, loading, metricType }) => {
  if (loading) return <Loading />;
  
  if (!metricData || metricData.length === 0) {
    return <p>No data available for {title}.</p>;
  }

  // Group metrics by name
  const metricsGroupedByName = {};
  metricData.forEach(metric => {
    const name = metric.metrics ? metric.metrics.name : 'Unknown';
    if (!metricsGroupedByName[name]) {
      metricsGroupedByName[name] = [];
    }
    metricsGroupedByName[name].push(metric);
  });

  // Generate datasets for the chart
  const datasets = Object.entries(metricsGroupedByName).map(([metricName, metrics]) => {
    const colorConfig = chartColors[metricType]?.[metricName.includes('cpu') ? 'cpu' : 'ram'] || chartColors[metricType]?.temp || chartColors[metricType]?.price;

    return {
      label: metricName,
      data: metrics.map(metric => ({
        x: new Date(metric.timestamp),
        y: metric.value
      })),
      borderColor: colorConfig.borderColor,
      backgroundColor: colorConfig.backgroundColor,
    };
  });

  // Sort data points by timestamp
  datasets.forEach(dataset => {
    dataset.data.sort((a, b) => new Date(a.x) - new Date(b.x));
  });

  // Find min and max values for y-axis scaling (with 10% padding)
  const allValues = metricData.map(metric => metric.value);
  const minValue = Math.min(...allValues);
  const maxValue = Math.max(...allValues);
  const yMin = Math.max(0, minValue - (maxValue - minValue) * 0.1);
  const yMax = maxValue + (maxValue - minValue) * 0.1;

  const options = {
    responsive: true,
    maintainAspectRatio: false,
    scales: {
      y: {
        min: yMin,
        max: yMax,
      },
      x: {
        type: 'time',
        time: {
          unit: 'minute',
          tooltipFormat: 'PP HH:mm',
          displayFormats: {
            minute: 'HH:mm'
          }
        },
        title: {
          display: true,
          text: 'Time'
        }
      },
    },
    plugins: {
      legend: {
        position: 'top',
      },
      title: {
        display: true,
        text: title,
      },
    },
  };

  return (
    <div style={{ width: '100%', maxWidth: '100%' }}>
      <MetricHeading>{title}</MetricHeading>
      <Button onClick={() => window.location.reload()}>Refresh Data</Button>
      <div style={{ width: '100%', height: '600px' }}>
        <Line options={options} data={{ datasets }} />
      </div>
    </div>
  );
};

export default Chart;
</code>

src\components\Gauge.jsx:
<code>
import React from 'react';
import { GaugeComponent } from 'react-gauge-component';
import styled from 'styled-components';

const GaugeWrapper = styled.div`
  text-align: center;
  width: 300px;
  padding: 20px;
  background-color: white;
  border-radius: 10px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transition: transform 0.3s, box-shadow 0.3s;

  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
  }

  h3 {
    margin: 0 0 10px 0;
    color: #333;
    font-size: 1.2rem;
  }
`;

const Gauge = ({ title, value, minValue, maxValue, unit }) => {
  return (
    <GaugeWrapper>
      <h3>{title}</h3>
      <GaugeComponent
        value={value}
        minValue={minValue}
        maxValue={maxValue}
        arc={{
          width: 0.2,
          padding: 0.005,
          cornerRadius: 1,
          colorArray: ['#5BE12C', '#EA4228'], // Gradient from green to red
        }}
        labels={{
          valueLabel: { formatTextValue: value => `${value}${unit}` },
          tickLabels: {
            type: 'inner',
            ticks: [
              { value: minValue },
              { value: (maxValue - minValue) / 2 },
              { value: maxValue },
            ],
          },
        }}
        pointer={{
          elastic: true,
        }}
      />
    </GaugeWrapper>
  );
};

export default Gauge;
</code>

src\components\Loading.jsx:
<code>
/*frontend/src/components/Loading.jsx*/
import React from 'react';
import styled from 'styled-components';

const LoadingOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
`;

const LoadingSpinner = styled.div`
  border: 5px solid #f3f3f3;
  border-top: 5px solid #009879;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
`;

const Loading = () => {
  return (
    <LoadingOverlay>
      <LoadingSpinner />
    </LoadingOverlay>
  );
};

export default Loading;
</code>

src\components\Table.jsx:
<code>
import React from 'react';
import styled from 'styled-components';
import { MetricHeading } from '../styles/StyledComponents';
import Loading from './Loading';

const StyledTable = styled.table`
  border-collapse: collapse;
  margin: 25px 0;
  font-size: 0.9em;
  font-family: sans-serif;
  min-width: 400px;
  width: 100%;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
`;

const TableHead = styled.thead`
  background-color: #009879;
  color: #ffffff;
  text-align: left;
  position: sticky;
  top: 0;
`;

const TableBody = styled.tbody`
  tr {
    border-bottom: 1px solid #dddddd;
    
    &:nth-of-type(even) {
      background-color: #f3f3f3;
    }
    
    &:last-of-type {
      border-bottom: 2px solid #009879;
    }
  }
`;

const TableRow = styled.tr``;

const TableHeader = styled.th`
  padding: 12px 15px;
`;

const TableCell = styled.td`
  padding: 12px 15px;
`;

const TabContainer = styled.div`
  margin-top: 20px;
`;

const TabButtons = styled.div`
  display: flex;
  margin-bottom: 10px;
`;

const TabButton = styled.button`
  padding: 10px 20px;
  background-color: ${props => props.active ? '#009879' : '#f1f1f1'};
  color: ${props => props.active ? 'white' : 'black'};
  border: none;
  cursor: pointer;
  transition: background-color 0.3s;
  
  &:hover {
    background-color: ${props => props.active ? '#007965' : '#ddd'};
  }
`;

const PaginationContainer = styled.div`
  display: flex;
  justify-content: center;
  margin-top: 10px;
`;

const PaginationButton = styled.button`
  background-color: #009879;
  color: white;
  border: none;
  padding: 10px;
  margin: 0 5px;
  cursor: pointer;
  border-radius: 5px;

  &:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
  }
`;

const formatDate = (dateString) => {
  const date = new Date(dateString);
  return date.toLocaleString();
};

const Table = ({ systemMetrics, weatherMetrics, cryptoMetrics, loading }) => {
  const [activeTab, setActiveTab] = React.useState('system');
  const [currentPage, setCurrentPage] = React.useState(0);
  const itemsPerPage = 10;

  if (loading) return <Loading />;

  const getPaginatedData = (data) => {
    const startIndex = currentPage * itemsPerPage;
    return data.slice(startIndex, startIndex + itemsPerPage);
  };

  const renderTable = () => {
    let data;
    let columns;
    
    switch(activeTab) {
      case 'system':
        data = systemMetrics;
        columns = ['Metric', 'Value', 'Timestamp'];
        break;
      case 'weather':
        data = weatherMetrics;
        columns = ['Metric', 'Value (Â°C)', 'Timestamp'];
        break;
      case 'crypto':
        data = cryptoMetrics;
        columns = ['Metric', 'Value (USD)', 'Timestamp'];
        break;
      default:
        data = [];
        columns = [];
    }
    
    if (!data || data.length === 0) {
      return <p>No data available for {activeTab} metrics.</p>;
    }

    const paginatedData = getPaginatedData(data);
    const totalPages = Math.ceil(data.length / itemsPerPage);

    return (
      <>
        <StyledTable>
          <TableHead>
            <TableRow>
              {columns.map((column, index) => (
                <TableHeader key={index}>{column}</TableHeader>
              ))}
            </TableRow>
          </TableHead>
          <TableBody>
            {paginatedData.map((row, index) => (
              <TableRow key={index}>
                <TableCell>{row.metrics ? row.metrics.name : 'Unknown'}</TableCell>
                <TableCell>{row.value.toFixed(2)}</TableCell>
                <TableCell>{formatDate(row.timestamp)}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </StyledTable>
        <PaginationContainer>
          <PaginationButton onClick={() => setCurrentPage(currentPage - 1)} disabled={currentPage === 0}>
            Previous
          </PaginationButton>
          <span>Page {currentPage + 1} of {totalPages}</span>
          <PaginationButton onClick={() => setCurrentPage(currentPage + 1)} disabled={currentPage >= totalPages - 1}>
            Next
          </PaginationButton>
        </PaginationContainer>
      </>
    );
  };
  
  return (
    <>
      <MetricHeading>Metrics History</MetricHeading>
      <TabContainer>
        <TabButtons>
          <TabButton 
            active={activeTab === 'system'} 
            onClick={() => setActiveTab('system')}
          >
            System Metrics
          </TabButton>
          <TabButton 
            active={activeTab === 'weather'} 
            onClick={() => setActiveTab('weather')}
          >
            Weather Metrics
          </TabButton>
          <TabButton 
            active={activeTab === 'crypto'} 
            onClick={() => setActiveTab('crypto')}
          >
            Crypto Metrics
          </TabButton>
        </TabButtons>
        {renderTable()}
      </TabContainer>
    </>
  );
};

export default Table;
</code>

src\styles\StyledComponents.jsx:
<code>
// frontend/src/styles/StyledComponents.jsx
import styled from 'styled-components';
import { Link as RouterLink } from 'react-router-dom';

// Layout components
export const Container = styled.div`
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
`;

export const HeaderBanner = styled.h1`
  background-color: #009879;
  color: white;
  padding: 20px;
  text-align: center;
  margin-top: 0;
  border-radius: 5px 5px 0 0;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
`;

export const Navigation = styled.nav`
  background-color: #f1f1f1;
  padding: 10px;
  margin-bottom: 20px;
  border-radius: 0 0 5px 5px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
`;

export const NavList = styled.ul`
  list-style-type: none;
  display: flex;
  padding: 0;
  margin: 0;
  
  li {
    margin-right: 20px;
    
    &:last-child {
      margin-right: 0;
    }
  }
`;

export const Link = styled(RouterLink)`
  text-decoration: none;
  color: #009879;
  font-weight: bold;
  padding: 5px 10px;
  border-radius: 3px;
  transition: background-color 0.3s, color 0.3s;
  
  &:hover {
    background-color: #009879;
    color: white;
  }
  
  &.active {
    background-color: #009879;
    color: white;
  }
`;

// Card and grid components
export const GridContainer = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
  margin-bottom: 30px;
  
  @media (max-width: 768px) {
    grid-template-columns: 1fr;
  }
`;

export const Card = styled.div`
  background-color: white;
  border-radius: 5px;
  padding: 20px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  transition: transform 0.3s, box-shadow 0.3s;
  
  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
  }
`;

// Button components
export const Button = styled.button`
  background-color: ${props => props.isFetching ? '#f44336' : '#009879'};
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  margin: 10px 0;
  transition: background-color 0.3s;

  &:hover {
    background-color: ${props => props.isFetching ? '#d32f2f' : '#007965'};
  }
`;
export const RetryButton = styled(Button)`
  background-color: #f44336;
  
  &:hover {
    background-color: #d32f2f;
  }
`;

// Container components
export const GaugeContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  height: 270px;
  
  h2 {
    margin-top: 0;
    color: #333;
  }
`;

export const ErrorContainer = styled.div`
  background-color: #ffebee;
  border-left: 4px solid #f44336;
  padding: 15px;
  margin-bottom: 20px;
  border-radius: 4px;
  
  p {
    color: #d32f2f;
    margin: 0 0 10px 0;
  }
`;

// Typography components
export const MetricHeading = styled.h2`
  color: #333;
  border-bottom: 2px solid #009879;
  padding-bottom: 10px;
  margin-top: 30px;
`;
</code>

